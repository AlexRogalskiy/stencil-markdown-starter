{"title":"Testing","description":"Testing overview.","contributors":["adamdbradley","brandyscarney","camwiegert"],"heading":[{"id":"testing","level":1,"text":"Testing"},{"id":"unit-testing-vs-end-to-end-testing","level":2,"text":"Unit Testing vs. End-to-end Testing"},{"id":"testing-commands","level":2,"text":"Testing Commands"}],"srcPath":"./src/docs/testing/overview.md","content":"<h1 id=\"testing\">Testing</h1>\n<p>Testing within Stencil is broken up into two distinct types: Unit tests and End-to-end (e2e) tests. Both types use <a href=\"https://jestjs.io/\">Jest</a> as the JavaScript testing solution. The browser environment for end-to-end testing is done using <a href=\"https://pptr.dev/\">Puppeteer</a>, which provides many advantages Stencil can start to incorporate into its builds.</p>\n<h2 id=\"unit-testing-vs-end-to-end-testing\">Unit Testing vs. End-to-end Testing</h2>\n<p>There are countless philosophies on how testing should be done, and what should be considered a unit test, end-to-end test or even integration tests. To simplify it all, Stencil tries to break it down to so developers have a defined description of when to use each type of testing.</p>\n<p>Unit testing is for testing small chunks of JavaScript code in isolation at the lowest level. For example, when a method is given the argument <code>X</code>, it should return <code>Y</code>. Unit tests should not be doing full rendering of the component, or even shallow rendering, but rather focused on logic only. Stencil likes to think of unit testing as specifically testing JavaScript code, and when given an input, the test should expect an exact output. With unit testing there is no simulating or mocking the component as an element in the DOM, but rather unit tests should import the component&#39;s class, create an instance, and test its methods and properties directly. Unit tests would also be the solution for testing utility functions and services used by components.</p>\n<p>End-to-end tests are one step further and would be testing rendering the components as elements in the DOM, and components working together. For example, when <code>my-component</code> has the <code>X</code> attribute, the child component then renders the text <code>Y</code>, and expects to receive the event <code>Z</code>. End-to-end tests are focused specifically on the DOM and how components interact with each other in the DOM. By using <a href=\"https://pptr.dev/\">Puppeteer</a> instead of a Node environment for rendering tests, end-to-end tests are able to run within an actual browser in order to provide more realistic results.</p>\n<p>Again, there are many theories and opinions on the definitions of &quot;unit testing&quot; and &quot;end-to-end testing&quot;, but by locking in these definitions and not blurring the lines between JavaScript testing and DOM testing it should help to quickly build out tests across large teams.</p>\n<h2 id=\"testing-commands\">Testing Commands</h2>\n<p>Below is an example <code>npm</code> script which can be added to the app&#39;s <code>package.json</code> file. Notice the command is <code>stencil test</code>, with optional flags of <code>--spec</code> for unit tests, and <code>--e2e</code> for end-to-end tests.</p>\n\n  <highlight-code-line >\n    <pre class=\"language-javascript\"><code class=\"language-javascript\">%22scripts%22%3A%20%7B%0A%20%20%22test%22%3A%20%22stencil%20test%20--spec%22%2C%0A%20%20%22test.watch%22%3A%20%22stencil%20test%20--spec%20--watch%22%2C%0A%20%20%22test.e2e%22%3A%20%22stencil%20test%20--e2e%22%0A%7D</code></pre>\n  </highlight-code-line>\n  <stencil-route-link url=\"/docs/style-guide\" router=\"#router\" custom=\"true\">\n  <button class=\"pull-left btn btn--secondary\">\n    Back\n  </button>\n</stencil-route-link>\n\n<stencil-route-link url=\"/docs/unit-testing\" custom=\"true\">\n  <button class=\"pull-right btn btn--primary\">\n    Next\n  </button>\n</stencil-route-link>\n"}